# -*- coding: utf-8 -*-
"""Copia de Python TOTAL - Numpy.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/15H9Bpq_wd6XRlrCQFns4VlDFmRDYZ-9w

# Práctica de la librería Numpy

En este notebook, se desarrollarán una serie de tareas utilizando la librería Numpy (Numerical Python).

Se proponen y documentan posibles formas de resolver los ejercicios, pero las mismas no son únicas.

Siempre es una buena idea verificar la [Documentación Oficial de Numpy](https://numpy.org/devdocs/user/index.html), donde es posible encontrar todo tipo de información referida a esta librería. Y si te quedas trabado, busca en Google "como hacer [algo] con Numpy". Hay enormes probabilidades de que esa pregunta ya haya sido respondida!
"""

# Importamos Numpy con su abreviación "np"
import numpy as np

# Podemos crear arrays de una dimensión con la función np.array()
array_unidim = np.array([1,2,3,4,5])

# O un array de dos dimensiones (bidimensional)
array_bidim = np.array([[1,2,3],[4,5,6]])

# O un array de tres dimensiones (tridimensional)
array_tridim = np.array([[[1,2,3],[4,5,6]],[[7,8,9],[10,11,12]]])

"""Para cada uno de estos arrays, podemos obtener sus propiedades, tales como su "forma", número de dimensiones, tipos de datos y tamaño."""

# Atributos del array unidimensional (forma, número de dimensiones, tipos de datos, tamaño, y tipo)
array_unidim.shape, array_unidim.ndim, array_unidim.dtype, array_unidim.size, type(array_unidim)

# Atributos del array bidimensional
array_bidim.shape, array_bidim.ndim, array_bidim.dtype, array_bidim.size, type(array_bidim)

# Atributos del array tridimensional
array_tridim.shape, array_tridim.ndim, array_tridim.dtype, array_tridim.size, type(array_tridim)

# Importamos pandas como pd, y creamos un DataFrame a partir del array bidimensional
import pandas as pd

datos = pd.DataFrame(array_bidim)
datos

# Creamos un array de tamaño 4x3, formado únicamente por unos (1)
unos = np.ones((4,3))
unos

# Creamos un array de tamaño 2x4x3, formado únicamente por ceros (0)
ceros = np.zeros((2,4,3))
ceros

# Creamos un array de números en el rango de 0 a 100, con un paso de 5
array_uno = np.arange(0,101,5)
array_uno

# Creamos un array de números aleatorios enteros comprendidos en entre 0 y 10, de tamaño (2, 5)
array_dos = np.random.randint(0,10,(2,5))
array_dos

# Creamos un array de números aleatorios decimales comprendidos en entre 0 y 1, de tamaño (3, 5)
array_tres = np.random.random((3,5))
array_tres

# Establecemos la "semilla" de números aleatorios en 27
np.random.seed(27)

# Creamos un array de números aleatorios enteros comprendidos en entre 0 y 10, de tamaño (3, 5)
array_cuatro = np.random.randint(0,10,(3,5))
array_cuatro

"""¿Qué ocurre al correr la última celda nuevamente, a diferencia de las anteriores?"""

# Encontramos los valores únicos del array_4
np.unique(array_cuatro)

# Extraemos el elemento de índice 1 del array_4
array_cuatro[1]

# Extraemos las primeras dos filas del array_4
array_cuatro[:2]

# Extraemos los dos primeros datos de las primeras dos filas del array_4
array_cuatro[:2,:2]

# Creamos dos arrays de tamaño 3x4: uno relleno de números aleatorios entre 0 y 10, y otro relleno de unos
array_cinco = np.random.randint(0,10,(3,4))
array_seis = np.ones((3,4))

# invocamos el array_5
array_cinco

# invocamos el array_6
array_seis

# Sumamos los dos arrays
array_cinco+array_seis

# Creamos ahora un array de tamaño (4,3) lleno de unos
array_siete = np.ones((4,3))
array_siete

# Intentaremos sumar los arrays 6 y 7
array_seis + array_siete

"""¿A qué se debe el error anterior? ¿Qué deberíamos tener en cuenta para que no suceda?"""

# Entonces crearemos otro array de tamaño (4,3) lleno de unos
array_ocho = np.ones((4,3))
array_ocho

# Restamos el array_8 al array_7
array_ocho - array_siete

# Creamos otros dos arrays de tamaño 3x3 con números aleatorios del 1 al 5
array_nueve = np.random.randint(1,5,(3,3))
array_diez = np.random.randint(1,5,(3,3))

# invocamos el array_9
array_nueve

# invocamos el array_10
array_diez

# Multiplicamos los últimos dos arrays entre sí
array_nueve * array_diez

# Elevamos el array_9 al cuadrado
array_nueve**2

# Buscamos la raíz cuadrada del array_10
np.sqrt(array_diez)

# Hallamos el promedio de los valores del array_9
array_nueve.mean()

# Hallamos el valor máximo de los valores del array_9
array_nueve.max()

# Hallamos el valor mínimo de los valores del array_9
array_nueve.min()

# Cambiamos la forma del array_9 por una de 9x1, y lo almacenamos como array_11
array_once = array_nueve.reshape((9,1))

# invocamos el array_11
array_once

# Transponemos el array_11
array_once.T

# Comparamos el array_9 y el array_10, para saber cuáles elementos del array_9 son mayores a los del array_10
array_doce = array_nueve > array_diez
array_doce

"""¿Qué tipos de datos forman parte del array de resultados?"""

# Veamos sus nuevos tipos de datos
array_doce.dtype

# Alguno de los elementos del array_9 es igual su equivalente del array_10?
array_nueve == array_diez

# Comparamos nuevamente ambos arrays, en esta ocasión con >=
array_nueve >= array_diez

# Buscamos los elementos del array_9 que son mayores a 2
array_nueve > 2

# Ordenamos de menor a mayor los elementos dentro del array_9
np.sort(array_nueve)